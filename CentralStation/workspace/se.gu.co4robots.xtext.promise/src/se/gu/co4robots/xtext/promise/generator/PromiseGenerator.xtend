/*
 * generated by Xtext 2.12.0
 */
package se.gu.co4robots.xtext.promise.generator

import java.util.ArrayList

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import promise.Mission
import promise.Location
import promise.OrderedLocation
import promise.NotOrderedLocation
import promise.Robot
import promise.Operator
import promise.Condition
import promise.CompositionOperator
import promise.DelegateOp
import promise.FallBackOp
import promise.SequenceOp
import promise.EventHandlerOp
import promise.ParallelOp
import promise.ConditionOp
import promise.Visit
import promise.Patrolling
import promise.InstantReaction
import promise.SimpleAction

import java.util.Iterator


/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
///////Robot class//////
public class robotClass{
	public var String name
	public var ArrayList<String> missionList
	public var int indentation
	
	new(String name, ArrayList<String> missionList, int indentation){
		this.name=name
		this.missionList=missionList
		this.indentation=indentation
	}
}
 //////////////////////
 
class PromiseGenerator extends AbstractGenerator {
	
	var robotsList = new ArrayList<ArrayList<robotClass>> //list of named lists of actions 
	var availableRobots= new ArrayList<String> //list with the available robots in a mission
	
	var stoppingEvents= new ArrayList<String> //list with the stopping events in the mission
	
	public override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		
		
			for (i:0..<(resource.allContents.filter(Robot).toIterable.length)) {
				availableRobots.add(resource.allContents.filter(Robot).toIterable.get(i).name)
				robotsList.add(new ArrayList<robotClass>)
				}
			

			robotsList.get(0).add(new robotClass(resource.allContents.filter(Robot).toIterable.get(0).name, new ArrayList<String>, 0))
			doLogic(resource.allContents.filter(Operator).toIterable.get(0), 0, 0, 0, availableRobots.get(0)) //perform the mission starting from the first robot and the first instantiation of robotClass
			var missionsList=new ArrayList<ArrayList<String>> //list of all the missions within the global mission
			var missions=new ArrayList<String> //list of each missions within the global mission
			
			fsa.generateFile('mission_data.ms', '''
			Robots [ «FOR robot : resource.allContents.filter(Robot).toIterable»«robot.name»,«ENDFOR» ]
			Events [ «FOR condition : resource.allContents.filter(Condition).toIterable»«IF condition.class == promise.impl.EventImpl»«condition.name» «condition.description»,«ENDIF»«ENDFOR» ]
			Actions [ «FOR condition : resource.allContents.filter(Condition).toIterable»«IF condition.class == promise.impl.ActionImpl»«condition.name» «condition.description»,«ENDIF»«ENDFOR» ]
			StoppingEvents [ «FOR j:0..<stoppingEvents.length»{«stoppingEvents.get(j)»}«ENDFOR» ]

		''')
		
		for (var i=0; i < availableRobots.length; i++){
			
			fsa.generateFile('mission_'+availableRobots.get(i)+'.ms', '''
			«FOR j:0..<robotsList.get(i).length»
				«IF robotsList.get(i).get(j).indentation == 0»
					«robotsList.get(i).get(j).name»«missions=robotsList.get(i).get(j).missionList»
				«ELSEIF robotsList.get(i).get(j).indentation == 1»
				
					«robotsList.get(i).get(j).name»«missions=robotsList.get(i).get(j).missionList»
				«ELSEIF robotsList.get(i).get(j).indentation == 2»
				
						«robotsList.get(i).get(j).name»«missions=robotsList.get(i).get(j).missionList»
				«ELSEIF robotsList.get(i).get(j).indentation == 3»
				
							«robotsList.get(i).get(j).name»«missions=robotsList.get(i).get(j).missionList»
				«ELSEIF robotsList.get(i).get(j).indentation == 4»
				
								«robotsList.get(i).get(j).name»«missions=robotsList.get(i).get(j).missionList»
				«ELSEIF robotsList.get(i).get(j).indentation == 5»
				
									«robotsList.get(i).get(j).name»«missions=robotsList.get(i).get(j).missionList»
				«ENDIF»
			«ENDFOR»


		''')
			
		}

		for (var i = robotsList.length-1 ; i >= 0; i--) for (var j = robotsList.get(i).length-1 ; j >= 0; j--) robotsList.get(i).remove(j) //Remove all the items of the list to avoid overwritting
 		for (var i = availableRobots.length-1 ; i >= 0; i--) availableRobots.remove(i)
 		for (var i = stoppingEvents.length-1 ; i >= 0; i--) stoppingEvents.remove(i)
		}
		
		//////////////////////////Methods
		
		def nestedMethod(CompositionOperator in, int index, int suboperator, int robot, int indentation, String parent){
			doLogic(in.inputOperators.get(suboperator), index, robot, indentation, parent)		
		}
		
		///////////////Composition operators
		
		def dispatch doLogic(SequenceOp in, int index, int robot, int indentation, String parent){
			var names = new ArrayList<String>
			var int counter 
			if (!robotsList.empty) { 
				for(counter = 0; counter<(robotsList.get(robot).length);counter++) names.add(robotsList.get(robot).get(counter).name)
			}
			for (i : 0..<(in.inputOperators.toArray.length)) nestedMethod(in, index, i, robot, indentation, parent) //nestedMethod(in, names.indexOf(parent), i, robot, indentation, parent) 
		}
		
		def dispatch doLogic(ParallelOp in, int index, int robot, int indentation, String parent){
			nestedMethod(in, index, 0, robot, indentation, availableRobots.get(robot))
			var names = new ArrayList<ArrayList<String>>
			var counter = new ArrayList<Integer>
			if (!robotsList.empty) { 
				for(var i = 0; i<(robotsList.length);i++) {
					counter.add(0)
					names.add(new ArrayList<String>)
					for(var j=0; j<(robotsList.get(i).length);j++){
						counter.add(i,j)
						names.get(robot+i).add(robotsList.get(robot+i).get(counter.get(j)).name) 
				}}
				}
			if (in.inputOperators.length > 0){
				for(i : 1..<(in.inputOperators.length)) {
					robotsList.get(robot+i).add(new robotClass(availableRobots.get(robot+i), new ArrayList<String>, indentation))
					names.get(robot+i).add(robotsList.get(robot+i).get(0).name)
					nestedMethod(in, names.get(i).indexOf(availableRobots.get(robot+i)), i, robot+i, indentation, availableRobots.get(robot+i))
				}}
		}
		
		def dispatch doLogic(EventHandlerOp in, int index, int robot, int indentation, String parent){
			robotsList.get(robot).get(index).missionList.add("eh")
			var int counter = robotsList.get(robot).length
			robotsList.get(robot).add(new robotClass("eh_default", new ArrayList<String>, indentation+1))
			nestedMethod(in, counter, 0, robot, indentation+1, "eh_default") //always execute the first operator, the following ones are the associated with events
			for(var i=1; i<(in.inputOperators.length); i++) {
				counter = robotsList.get(robot).length
				robotsList.get(robot).add(new robotClass("eh_"+in.inputObservedEvents.get(i-1).name, new ArrayList<String>, indentation+1))
				nestedMethod(in, counter, i, robot, indentation+1, "eh_"+in.inputObservedEvents.get(i-1).name)
			}
		}
		
		def dispatch doLogic(FallBackOp in, int index, int robot, int indentation, String parent){
			robotsList.get(robot).get(index).missionList.add("fb")
			var int counter = robotsList.get(robot).length
			for(var i=1; i<=(in.inputOperators.length); i++) {
				counter = robotsList.get(robot).length
				robotsList.get(robot).add(new robotClass("fb_"+i, new ArrayList<String>, indentation+1))
				nestedMethod(in, counter++, i-1, robot, indentation+1, "fb_"+i)
			}	
		}
		def dispatch doLogic(ConditionOp in, int index, int robot, int indentation, String parent){
			robotsList.get(robot).get(index).missionList.add("cond")
			var int counter = robotsList.get(robot).length
			for(var i=1; i<=(in.inputOperators.length); i++) {
				counter = robotsList.get(robot).length
				robotsList.get(robot).add(new robotClass("cond_"+in.inputEvents.get(i-1).name, new ArrayList<String>, indentation+1))
				nestedMethod(in, counter, i-1, robot, indentation+1, "cond_"+in.inputEvents.get(i-1).name)
			}
		}
		
		/////////////////Delegate operators
		
		def dispatch doLogic(DelegateOp in, int index, int robot, int indentation, String parent){

////////////////Passing an LTL formula
			var template = new String 
			
			////Core Movement Patterns
			if(in.pattern.eClass.name == "Visit") {
				template="<> ("+in.inputLocations.get(0).name+")"
				for(var i=1; i<in.inputLocations.length; i++) 	template=template+" && <> ("+in.inputLocations.get(i).name+")"
			}
			else if(in.pattern.eClass.name == "FairVisit") {
				template="<> ("+in.inputLocations.get(0).name+")"
				for(var j=0; j<in.inputLocations.length; j++) {
					if (j==0) {
						for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> ("+in.inputLocations.get(i).name+")" //sets the first line
						template=template+" && [] (("+in.inputLocations.get(j).name+") -> X ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(j+1).name+") || ([] (!"+in.inputLocations.get(j).name+"))))"						//sets the first part of the second line
						for(var i=2; i<in.inputLocations.length; i++) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(j+1).name+") || ([] (!"+in.inputLocations.get(j).name+")))"	//Rest of the second line
					}
					else{
						template=template+" && [] (("+in.inputLocations.get(j).name+") -> X ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(0).name+") || ([] (!"+in.inputLocations.get(j).name+"))))"	//subsequent "3rd lines"
						for(var i=1; i<in.inputLocations.length; i++) if (i != j) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+") || ([] (!"+in.inputLocations.get(j).name+")))"
					}
				}
			}
			else if(in.pattern.eClass.name == "OrderderVisit") {
				template="(<> ("+in.inputLocations.get(0).name+")"

				for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> (("+in.inputLocations.get(i).name+")" //sets the first line
				for(var i=0; i<in.inputLocations.length; i++) template=template+")"
				for(var j=in.inputLocations.length-1; j>0; j--){
					for(var i=j-1; i>=0; i--) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+"))"
				}
			}	
			else if(in.pattern.eClass.name == "SequencedVisit") {
				template="<> (("+in.inputLocations.get(0).name+")"
				for(var i=1; i<in.inputLocations.length; i++) template=template+" && (<> ("+in.inputLocations.get(i).name+")" 
				for(var i=0; i<in.inputLocations.length; i++) template=template+")"
			}	
			else if(in.pattern.eClass.name == "StrictOrderedVisit") {
				template="<> (("+in.inputLocations.get(0).name+")"
				for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> ("+in.inputLocations.get(i).name+")" //sets the first line
				template=template+")"
				for(var j=in.inputLocations.length-1; j>=0; j--){
					for(var i=in.inputLocations.length-1; i>=0; i--) {
						if (i != j) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+"))"
						}
				}
				for(var j=in.inputLocations.length-1; j>0; j--){
					for(var i=j-1; i>=0; i--) {
						if (i != j) template=template+" && <> ("+in.inputLocations.get(j).name+" && X(((! "+in.inputLocations.get(j).name+")) U "+in.inputLocations.get(i).name+"))"
					}
				}
			}
			else if(in.pattern.eClass.name == "Patrolling") {
				template="[] (<> ("+in.inputLocations.get(0).name+")"
				for(var i=1; i<in.inputLocations.length; i++) 	template=template+" && <> ("+in.inputLocations.get(i).name+")"
				template=template+")"
			}
			else if(in.pattern.eClass.name == "FairPatrolling") {
				template="[] (<> ("+in.inputLocations.get(0).name+")"
				for(var j=0; j<in.inputLocations.length; j++) {
					if (j==0) {
						for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> ("+in.inputLocations.get(i).name+")" //sets the first line
						template=template+") && [] (("+in.inputLocations.get(j).name+") -> X ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(j+1).name+"))"						//sets the first part of the second line
						for(var i=2; i<in.inputLocations.length; i++) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+"))"	//Rest of the second line
						template=template+")"
					}
					else{
						template=template+" && [] (("+in.inputLocations.get(j).name+") -> X ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(0).name+"))"	//subsequent "3rd lines"
						for(var i=1; i<in.inputLocations.length; i++) if (i != j) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+"))"
					}
				}
				template=template+")"
			}
			else if(in.pattern.eClass.name == "OrderedPatrolling") {
				template="[] (<> (("+in.inputLocations.get(0).name+")"

				for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> (("+in.inputLocations.get(i).name+")" //sets the first line
				for(var i=0; i<in.inputLocations.length; i++) template=template+")"
				for(var j=in.inputLocations.length-1; j>0; j--){
					for(var i=j-1; i>=0; i--) template=template+" && (! ("+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+"))"
				}
				for(var j=in.inputLocations.length-1; j>0; j--){
					for(var i=j-1; i>=0; i--) template=template+" && [] ("+in.inputLocations.get(j).name+" -> X((! "+in.inputLocations.get(j).name+") U "+in.inputLocations.get(i).name+"))"
				}
			}	
			else if(in.pattern.eClass.name == "StrictOreredPatrolling") {
				template="[] (<> (("+in.inputLocations.get(0).name+")"
				for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> (("+in.inputLocations.get(i).name+")" //sets the first line
				for(var i=0; i<in.inputLocations.length; i++) template=template+")"
				for(var j=in.inputLocations.length-1; j>=0; j--){
					for(var i=in.inputLocations.length-1; i>=0; i--) {
						if (i != j) template=template+" && ((!"+in.inputLocations.get(j).name+") U ("+in.inputLocations.get(i).name+"))"
						}
				}
				for(var j=in.inputLocations.length-1; j>0; j--){
					for(var i=j-1; i>=0; i--) {
						if (i != j) template=template+" && [] ("+in.inputLocations.get(j).name+" -> X((! "+in.inputLocations.get(j).name+")) U "+in.inputLocations.get(i).name+"))"
					}
				}
			}		
			else if(in.pattern.eClass.name == "SequencedPatrolling") {
				template="[] (<> (("+in.inputLocations.get(0).name+")"
				for(var i=1; i<in.inputLocations.length; i++) template=template+" && <> (("+in.inputLocations.get(i).name+")" 
				for(var i=0; i<in.inputLocations.length*2-1; i++) template=template+")"
			}		
			
			////Avoidance patterns
			else if(in.pattern.eClass.name == "ExactRestrictedAvoidance") template="(! ("+in.inputAction.get(0).description+")) U ("+in.inputAction.get(0).description+" && (X ((! "+in.inputAction.get(0).description+") U ("+in.inputAction.get(0).description+" && (X ((! "+in.inputAction.get(0).description+") U ("+in.inputAction.get(0).description+" && (X ([] (!  "+in.inputAction.get(0).description+"))))))))))"
			else if(in.pattern.eClass.name == "FutureAvoidance") template="[] (("+in.inputAction.get(0).description+ "-> ([] ! ("+in.inputLocations.get(0).name+"))"
			else if(in.pattern.eClass.name == "GlobalAvoidance") template="[] (! ("+in.inputLocations.get(0).name+"))"
			else if(in.pattern.eClass.name == "LowerRestricedAvoidance") template="<> (("+in.inputLocations.get(0).name+ ") && X (<>(("+in.inputLocations.get(0).name+") && X <>( ("+in.inputLocations.get(0).name+")))))"
			else if(in.pattern.eClass.name == "PastAvoidance") template="((! ("+in.inputLocations.get(0).name+")) U "+in.inputLocations.get(0).name+")"
			else if(in.pattern.eClass.name == "UpperRestricedAvoidance") template="! <> (("+in.inputLocations.get(0).name+ ") && X (<>(("+in.inputLocations.get(0).name+") && X <>( ("+in.inputLocations.get(0).name+")))))"
		
			////Triggers
			else if(in.pattern.eClass.name == "InstantReaction") template="[] (true -> "+in.inputAction.get(0).description+")" //Pattern version of InstantReaction, replaced by the KTH planner compatible version
			else if(in.pattern.eClass.name == "DelayedReaction") template="[] (true -> (<> ("+in.inputAction.get(0).description+"))"
			else if(in.pattern.eClass.name == "Wait") {
				//Correct implementation, waiting for Claudio's input
//				if (in.inputAction.isEmpty) template="("+in.inputLocations.get(0).name+") U (true)"
//				else if (in.inputLocations.isEmpty) template="("+in.inputAction.get(0).description+") U (true)"
				//Debug version
				template="[] (<> ("+in.inputLocations.get(0).name+"))"
			}
			else if(in.pattern.eClass.name == "SimpleAction") template="(X "+in.inputAction.get(0).description+")"
		
			else template="Pattern not recognized"
			//println(template)
			
			if(in.stoppingEvent.size() > 0){
				for(var i=0; i<in.stoppingEvent.length; i++){
					stoppingEvents.add(availableRobots.get(robot)+','+template+','+in.stoppingEvent.get(i).name)
				}
			}
			robotsList.get(robot).get(index).missionList.add(template)
			
		}
		

		
		/////////////////////////Printing methods
		
//		def ArrayList<ArrayList<String>>  printOut(){
//			var template = new ArrayList<ArrayList<String>>  
//			for (i : 0..<(robotsList.length)) template.add(robotsList.get(robot).get(i).missionList)		 
//			return template
//		}

}
